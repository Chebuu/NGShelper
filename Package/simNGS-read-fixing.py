#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------

'''

This source fixes sequence identifiers of a read file generated by simNGS to compatible format with CASAVA.

    Each read entry in a FASTQ file consists of four records:
        - Sequence identifier 
        - Sequence 
        - Quality score identifier line (consisting of a +) 
        - Quality score 

    In CASAVA, each sequence identifier, the line that precedes the sequence and describes it, needs to be
    in the following format:
        @<instrument>:<run>:<flowcell>:<lane>:<tile>:<x_pos>:<y_pos> <read>:<is_filtered>:<control>:<index>

    Where:

        instrument = Instrument ID (Characters allowed: a-z, A-Z, 0-9 and underscore)
        run = Run number on instrument (Numerical)
        flowcell = Flowcell ID (Characters allowed: a-z, A-Z, 0-9)
        lane = Lane number (Numerical)
        tile = Tile number (Numerical)
        x_pos = X coordinate of cluster (Numerical)
        y_pos = Y coordinate of cluster (Numerical)

        read = Read number. 1 can be single read or read 2 of paired-end  (Numerical)
        is_filtered = Y if the read is filtered, N otherwise (Y or N)
        control = 0 when none of the control bits are on, otherwise it is an even number (Numerical)
        index = Index sequence (ACTG)

    Sequence identifier example:
        @EAS139:136:FC706VJ:2:5:1000:12850 1:Y:18:ATCACG
        @MG00HS20:721:C7JR3ANXX:1:1101:18066:6008 1:N:0:CGATGT

'''

#-------------------------------------------------------------------------------

import argparse
import os
import re
import subprocess
import sys

#-------------------------------------------------------------------------------

def main(argv):
    '''
    Main line of the program.
    '''

    # verify the operating system
    verify_os()

    # get and verify the arguments
    parser = build_parser()
    args = parser.parse_args()
    verify_args(args)

    # set default values in sequence identifier data
    instrument = 'MG00HS20'
    run = 1
    flowcell = 'XXX'
    lane = 1
    tile = 1
    filenum = args.filenum
    is_filtered = 'N'
    control = 0
    index = 'ACTG' if filenum == 1 else 'GTCA'

    # verify if read file is a GZ file
    if args.readfile.endswith('.gz'):
        is_gz = True
    else:
        is_gz = False

    # set the read file and the fixed read file path
    readfile = args.readfile
    fixed_readfile = os.path.dirname(readfile) + 'fixed_' + os.path.basename(readfile)

    # open the read file
    try:
        if is_gz:
            readfile_id = gzip.open(readfile, mode='rt', encoding='iso-8859-1')
        else:
            readfile_id = open(readfile, mode='r', encoding='iso-8859-1')
    except:
        raise ProgramException('F001', readfile)
  
    # open the fixed read file
    try:
        if is_gz:
            fixed_readfile_id = gzip.open(fixed_readfile, mode='wt', encoding='iso-8859-1')
        else:
            fixed_readfile_id = open(fixed_readfile, mode='w', encoding='iso-8859-1')
    except:
        raise ProgramError('F001', fixed_readfile)

    # set the pattern of the sequence identifier record
    pattern = r'^@Frag_([0-9]+) (\S+) .* Strand ([\+\-]) Offset ([0-9]+--[0-9]+) .*$'

    # read the first record of readfile
    record = readfile_id.readline()

    # while there are records in readfile
    while record != '':

        # process the sequence identifier record
        if record.startswith('@'):

            # extract the data
            record = record.replace('(','')
            record = record.replace(')','')
            mo = re.search(pattern, record)
            fragment = mo.group(1)
            transcript = mo.group(2)
            strand = mo.group(3)
            offset = mo.group(4)

            # build the fixed sequence identifier record
            # -- instrument = '___{0}___{1}___{2}___{3}___'.format(fragment, transcript, strand, offset)
            flowcell = '{0}'.format(fragment)
            x_pos = y_pos = fragment
            fixed_record = '@{0}:{1}:{2}:{3}:{4}:{5}:{6} {7}:{8}:{9}:{10}\n'.format(instrument, run, flowcell, lane, tile, x_pos, y_pos, filenum, is_filtered, control, index)

            # write the fixed sequence identifier record
            fixed_readfile_id.write(fixed_record)

        else:
            # control the FASTQ format
            raise ProgramError('F003', readsfile, 'FASTQ')

        # read next record and process the sequence record
        record = readfile_id.readline()
        if record != '':
            fixed_readfile_id.write(record)
        else:
            # control the FASTQ format
            raise ProgramError('F003', readsfile, 'FASTQ')

        # read next record and process quality score identifier record
        record = readfile_id.readline()
        if record.startswith('+'):
            fixed_readfile_id.write(record)
        else:
            # control the FASTQ format
            raise ProgramError('F003', readsfile, 'FASTQ')

        # read next record and process quality score record
        record = readfile_id.readline()
        if record != '':
            fixed_readfile_id.write(record)
        else:
            # control the FASTQ format
            raise ProgramError('F003', readsfile, 'FASTQ')

        # read the next record
        record = readfile_id.readline()

    # close files
    readfile_id.close()
    fixed_readfile_id.close()

    # show OK message
    print('The file {0} with cut reads has been created.'.format(fixed_readfile))

#-------------------------------------------------------------------------------

def verify_os():
    '''
    Verify the operating system.
    '''    

    # if the operating system is unsupported, exit with exception
    if not sys.platform.startswith('linux') and not sys.platform.startswith('darwin') and not sys.platform.startswith('win32') and not sys.platform.startswith('cygwin'):
        raise ProgramException('S001', sys.platform)

#-------------------------------------------------------------------------------

def build_parser():
    '''
    Build the parser with the available options.
    '''

    #create the parser and add options
    parser = argparse.ArgumentParser(description='This program fixes sequence identifiers of a read file generated by simNGS to compatible format with CASAVA.')
    parser.add_argument('-n', '--filenum', dest='filenum', help='1: in SE file or the first file in PE files; 2: the second file in PE files')
    parser.add_argument('-r', '--readfile', dest='readfile', help='Path of a read file generated by simNGS in FASTQ format')

    # return the paser
    return parser

#-------------------------------------------------------------------------------

def verify_args(args):
    '''
    Verity the input arguments data.
    '''

    # initialize the control variable
    OK = True

    # verify filenum
    if args.filenum is None:
        print('The file number must be indicated  in the input arguments.')
        OK = False
    else:
        try:
            args.filenum = int(args.filenum)
        except:
            print('The value {0} of file number is not 1 or 2.'.format(args.filenum))
            OK = False
        if args.filenum not in [1, 2]:
            print('The value {0} of file number is not 1 or 2.'.format(args.filenum))
            OK = False

    # verify readfile
    if args.readfile is None:
        print('A read file generated by simNGS in FASTQ format has not been indicated in the input arguments.')
        OK = False
    else:
        if not os.path.isfile(args.readfile):
            print('The file {0} does not exist.'.format(args.readfile))
            OK = False
        if not args.readfile.endswith('.fastq') and not args.readfile.endswith('.fq') and not args.readfile.endswith('.fastq.gz') and not args.readfile.endswith('.fq.gz'):
            print('The file {0} does not end in ".fastq", ".fq", ".fastq.gz or ".fq.gz".'.format(args.readfile))
            OK = False

    # if there are errors, exit with exception
    if not OK:
        raise ProgramException('P001', sys.platform)

#-------------------------------------------------------------------------------

def trace():
    '''Return if the traces must be printed.'''

    # assign the value (True can be assigned if the traces are necessary)
    traces_printed = False
    # -- traces_printed = True

    # return the value
    return traces_printed

#-------------------------------------------------------------------------------
 
class ProgramException(Exception):
    '''
    This class controls various exceptions that can occur in the execution of the application.
    '''

   #---------------

    def __init__(self, code_exception, param1='', param2='', param3=''):
        '''Initialize the object to manage a passed exception.''' 

        # manage the code of exception
        if code_exception == 'EXIT':
            sys.exit(0)
        elif code_exception == 'F001':
            print('*** ERROR {0}: This file {1} can not be opened.'.format(code_exception, param1), file=sys.stderr)
            sys.exit(1)
        elif code_exception == 'F002':
            print('*** ERROR {0}: Format file {1} is not {2}.'.format(code_exception, param1, param2), file=sys.stderr)
        elif code_exception == 'P001':
            print('*** ERROR {0}: This program has parameters with invalid values.'.format(code_exception), file=sys.stderr)
            sys.exit(1)
        elif code_exception == 'S001':
            print('*** ERROR {0}: The {1} OS is not supported.'.format(code_exception, param1), file=sys.stderr)
            sys.exit(1)
        else:
            print('*** ERROR {0}: This exception is not managed.'.format(code_exception), file=sys.stderr)
            sys.exit(1)

   #---------------

#-------------------------------------------------------------------------------

if __name__ == '__main__':

    main(sys.argv[1:])
    sys.exit(0)

#-------------------------------------------------------------------------------
